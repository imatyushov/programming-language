## Идея
Lexer -> Parser -> AST

Реализовать свой собственный язык программирования, который опирается на определенную уже известную грамматику

## Задание 1

Реализуем лексический анализатор.

Лексический анализатор преобразует последовательность символов в последовательность лексем.

На уровне лексического анализа могут обнаруживаться ошибки о них надо сообщать.

Два основных требования:

- сообщения должны быть базового информативными и разные ошибки должны давать отличимые сообщения
- сообщение должно указывать местоположение проблемы в терминах "номер строки и номер колонки". Номер строки/колонки начинается с 1.

## Задание 2

Поверх лексического анализатора реализуем синтаксический.

### Подход

Эта задача посложнее, потому что тут недостаточно по текущей позиции понять, что тут за конструкция находится, и немножко заглянуть вперед. Тут начинаются рекурсивно вложенные конструкции.

Язык может быть формально описан грамматикой, то есть набором правил, определяющим, является ли входная последовательность корректной с точки зрения данного языка.

Пример грамматики можно видеть здесь: https://en.wikipedia.org/wiki/Recursive_descent_parser#Example_parser

По грамматике можно построить синтаксический анализатор. Для развитых языков программирования они строятся автоматически парсер-генераторами. Но у нас язык простой и мы напишем его (парсер) сами методом рекурсивного спуска.

В примере грамматики по ссылке если красные и зеленые элементы. Красные - это терминальные символы, базовые элементы. Зеленые - нетерминальные. По сути они задают некую структуру языка. А чисто формально - один из нетерминальных символов является стартовым.
И синтаксический анализ - это процесс построения цепочки подстановок, в котором на каждом шаге нетерминальный символ заменяется на цепочку из правой части одного из правил грамматики (в котором он стоит в левой части).

### Грамматика: начало

Терминальные символы - это лексемы, полученные из лексического анализатора. Иногда к ним удобно добавить маркер конца - `EOF`.

(Эта нотация называется расширенной формой Бекуса-Наура. Она кажется интуитивно понятной. Если что-то неясно, можно почитать здесь: https://en.wikipedia.org/wiki/Extended_Backus–Naur_form  или спросить меня).

### Рекурсивный спуск

Мы пишем парсер по этим правилам.

Отпарсить программу - отпарсить последовательность условных блоков (возможно, пустую) и увидеть за ней конец потока лексем.

Пришло что-то, похожее на условное выражение - пытаемся отпарсить его. И так далее. Некоторые конструкции могут вкладываться сами в себя, отсюда и рекурсивность. А спуск - потому что идет от самого высокоабстрактного нетерминала к лексемам. (Бывают методы, которые наоборот - идут от лексем, ищут правила и пытаются построить дерево разбора "снизу вверх").

Подробнее про метод можно почитать здесь: https://en.wikipedia.org/wiki/Recursive_descent_parser.

Мы же доопределим язык.

## Задание 3

Дерево синтаксического разбора еще не очень удобно. Например дерево выражения `1 + 2 + 3 + 4 + 5` будет бинарным и немного перекошенным.


## Задание 4

Научимся как-то исполнять наш код.





